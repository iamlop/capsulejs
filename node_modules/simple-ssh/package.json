{
  "name": "simple-ssh",
  "version": "0.7.4",
  "description": "A wrapper for ssh2 to make it easier to perform commands over SSH",
  "keywords": [
    "ssh",
    "ssh2"
  ],
  "author": {
    "name": "Mike Cluck",
    "email": "mcluck90@gmail.com"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/MCluck90/simple-ssh/blob/master/LICENSE.txt"
    }
  ],
  "main": "./lib/ssh.js",
  "repository": {
    "type": "git",
    "url": "http://github.com/MCluck90/simple-ssh.git"
  },
  "devDependencies": {
    "expect.js": "~0.2.0",
    "grunt-contrib-watch": "~0.4.4",
    "grunt-simple-mocha": "~0.4.0",
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.6.0"
  },
  "dependencies": {
    "xtend": "~2.0.6",
    "ssh2": "~0.2.10"
  },
  "readme": "# simple-ssh\r\n\r\nA wrapper for the [ssh2 client module by Brian White][1] which makes it easier to run a sequence of commands over SSH.\r\n\r\n# Requirements\r\n\r\n* [node.js][2] -- v0.8.7 or newer\r\n\r\n# Install\r\n\r\n    npm install simple-ssh\r\n\r\n# Examples\r\n\r\n* Echoing out a users `PATH`:\r\n\r\n```javascript\r\nvar SSH = require('simple-ssh');\r\n\r\nvar ssh = new SSH({\r\n    host: 'localhost',\r\n    user: 'username',\r\n    pass: 'password'\r\n});\r\n\r\nssh.exec('echo $PATH', {\r\n    out: function(stdout) {\r\n        console.log(stdout);\r\n    }\r\n}).start();\r\n\r\n/*** Using the `args` options instead ***/\r\nssh.exec('echo', {\r\n    args: ['$PATH'],\r\n    out: function(stdout) {\r\n        console.log(stdout);\r\n    }\r\n}).start();\r\n```\r\n\r\n* Capturing error output:\r\n\r\n```javascript\r\nssh.exec('this-does-not-exist', {\r\n    err: function(stderr) {\r\n        console.log(stderr); // this-does-not-exist: command not found\r\n    }\r\n}).start();\r\n```\r\n\r\n* Capturing error codes:\r\n\r\n```javascript\r\nssh.exec('exit 69', {\r\n    exit: function(code) {\r\n        console.log(code); // 69\r\n    }\r\n}).start();\r\n```\r\n\r\n* Chaining commands together:\r\n\r\n```javascript\r\nssh\r\n    .exec('echo \"Node.js\"', {\r\n        out: console.log\r\n    })\r\n    .exec('echo \"is\"', {\r\n        out: console.log\r\n    })\r\n    .exec('echo \"awesome!\"', {\r\n        out: console.log\r\n    })\r\n    .start();\r\n\r\n// Output:\r\n// Node.js\r\n// is\r\n// awesome!\r\n```\r\n\r\n* Get the number of commands:\r\n\r\n```javascript\r\nssh\r\n    .exec('exit 1')\r\n    .exec('exit 2')\r\n    .exec('exit 3');\r\n\r\nconsole.log(ssh.count()); // 3\r\n```\r\n\r\n* Running a command using `sudo`\r\n\r\n```javascript\r\nssh.exec('sudo echo \"Pseudo-sudo\"', {\r\n    pty: true,\r\n    out: console.log\r\n}).start();\r\n```\r\n\r\n* Resetting a connection and the commands\r\n\r\n```javascript\r\n// Echos out any messages the user sent in if 10 or more have been queued\r\nvar msgInterval = setInterval(function() {\r\n    if (ssh.count() > 10) {\r\n        ssh.start();\r\n    }\r\n}, 1000);\r\n\r\nsocket.on('message', function(msg) {\r\n    // If a 'reset' message is received, clear previous messages\r\n    if (msg === 'reset') {\r\n        ssh.reset(function(err) {\r\n            if (err) {\r\n                throw err;\r\n            }\r\n\r\n            ssh.exec('echo \"reset\"');\r\n        });\r\n    } else {\r\n        ssh.exec('echo \"' + msg + '\"');\r\n    }\r\n});\r\n```\r\n\r\n* Listening for additional events\r\n\r\n```javascript\r\nssh.on('error', function(err) {\r\n    console.log('Oops, something went wrong.');\r\n    console.log(err);\r\n    ssh.end();\r\n});\r\n```\r\n\r\n* Event handlers can be chained as well\r\n\r\n```javascript\r\nssh\r\n    .on('error', onSSHError)\r\n    .on('ready', onSSHReady);\r\n```\r\n\r\n----------\r\n\r\n# API\r\n\r\n### Functions\r\n\r\n* **Constructor**( [ _config_ ] )\r\n    * **config** { _Object_ }:\r\n        * **config.host** {  _String_ }: Hostname\r\n        * **config.port** { _Number_ }: Port number (default: `22`)\r\n        * **config.user** { _String_ }: Username\r\n        * **config.pass** { _String_ }: Password\r\n* **exec**( _command_, [ _options_ ] ): **Adds a command to the stack**\r\n    * **command** { _String_ }: Command to be executed\r\n    * **options** { _Object_ }:\r\n        * **options.args** { _String[]_ }: Additional command line arguments (default: `null`)\r\n        * **options.out** { _Function( stdout )_ }: `stdout` handler\r\n            * **stdout** { _String_ }: Output streamed through `stdout`\r\n        * **options.err** { _Function( stderr )_ }: `stderr` handler\r\n            * **stderr** { _String_ }: Output streamed through `stderr`\r\n        * **options.exit** { _Function( code, stdout, stderr )_ }: Exit handler\r\n            * **code** { _Number_ }: Exit code\r\n            * **stdout** { _String_ }: All of the standard output concatenated together\r\n            * **stderr** { _String_ }: All of the error output concatenated together\r\n        * **options.pty** { _Boolean_ }: Allocates a pseudo-tty, useful for command which require `sudo` (default: `false`)\r\n* **on**( _event_, _callback_ ): **Add a listener for the specified event** (Courtesy of [@alexandrejablon][3])\r\n    * **event** { _String_ }: Event to listen to\r\n    * **callback** { _Function_ }: Executed on the event\r\n* **start**( [ _options_ ] ): **Starts executing the commands**\r\n    * **options** { _Object_ }:\r\n        * **options.success** { _Function()_ }: Called on successful connection\r\n        * **options.fail** { _Function( err )_ }: Called if the connection failed\r\n            * **err** { _Error_ }: Error information\r\n* **reset**( [ _callback_ ] ): **Clears the command queue and resets the current connection**\r\n    * **callback** { _Function( err )_ }: Called when the connection has been successfully reset\r\n        * **err** { _Error_ }: Error information\r\n* **end**(): **Ends the SSH session** (this is automatically called at the end of a command queue).\r\n\r\n### Flow Control\r\n\r\nSometimes you may find yourself needing to change which commands are executed. The flow can be changed by returning `false` from an `exit` handler.\r\n\r\n**Note**: This only works if `false` is explicitly returned. \"Falsy\" values are not sufficient (since `undefined` is implicitly returned and it's \"falsy\").\r\n\r\n* Ending prematurely:\r\n\r\n```javascript\r\nssh\r\n    .exec('pwd', {\r\n        exit: function() {\r\n            return false;\r\n        }\r\n    })\r\n    .exec('echo \"Not executed\"')\r\n    .start();\r\n```\r\n\r\n* Running a new queue of commands:\r\n\r\n```javascript\r\nssh\r\n    .exec('exit', {\r\n        args: [ Math.round(Math.random()) ],\r\n        exit: function(code) {\r\n            if (code === 1) {\r\n                // Setup the new command queue\r\n                ssh.exec('echo \"new queue\"');\r\n                return false;\r\n            }\r\n        }\r\n    })\r\n    .exec('exit 0', {\r\n        exit: function() {\r\n            console.log('Previous command did not return false');\r\n        }\r\n    })\r\n    .start();\r\n```\r\n\r\n  [1]: https://github.com/mscdex/ssh2\r\n  [2]: http://nodejs.org\r\n  [3]: https://github.com/alexandrejablon",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/MCluck90/simple-ssh/issues"
  },
  "homepage": "https://github.com/MCluck90/simple-ssh",
  "_id": "simple-ssh@0.7.4",
  "_from": "simple-ssh@^0.7.4"
}
